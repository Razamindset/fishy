import { Chess } from "chess.js";

//! Some code is generated by claude
export class ChessGame {
  constructor(player1, player2, timeSeconds) {
    this.id = `game_${Date.now()}_${Math.random()
      .toString(36)
      .substring(2, 10)}`;

    // Randomly assign colors
    const isPlayer1White = Math.random() < 0.5;

    // Player information
    this.players = {
      white: {
        ...(isPlayer1White ? player1 : player2),
        timeRemaining: timeSeconds * 1000, // Convert to milliseconds
        connected: false,
        socketId: isPlayer1White ? player1.socketId : player2.socketId,
      },
      black: {
        ...(isPlayer1White ? player2 : player1),
        timeRemaining: timeSeconds * 1000,
        connected: false,
        socketId: isPlayer1White ? player2.socketId : player1.socketId,
      },
    };

    // Game state
    this.status = "pending"; // pending, active, paused, completed, abandoned
    this.startTime = null;
    this.lastMoveTime = null;
    this.currentTurn = "white";
    this.winner = null;
    this.gameOverReason = null;

    // Chess logic
    this.chess = new Chess();
    this.moveHistory = [];

    // Timers
    this.timerInterval = null;
  }

  // Player connection management
  handlePlayerConnect(socketId) {
    const color = this.getPlayerColor(socketId);
    if (color) {
      this.players[color].connected = true;
      if (this.areAllPlayersConnected() && this.status === "pending") {
        this.startGame();
      }
      return true;
    }
    return false;
  }

  handlePlayerDisconnect(socketId) {
    const color = this.getPlayerColor(socketId);
    if (color) {
      this.players[color].connected = false;
      this.pauseGame();
      return {
        color,
        timeRemaining: this.players[color].timeRemaining,
        gameStatus: this.status,
      };
    }
    return null;
  }

  // Game state management
  startGame() {
    this.status = "active";
    this.startTime = Date.now();
    this.lastMoveTime = Date.now();
    this.startTimers();
  }

  pauseGame() {
    if (this.status === "active") {
      this.status = "paused";
      this.stopTimers();
    }
  }

  resumeGame() {
    if (this.status === "paused" && this.areAllPlayersConnected()) {
      this.status = "active";
      this.lastMoveTime = Date.now();
      this.startTimers();
    }
  }

  // Move handling
  makeMove(from, to, promotion) {
    if (this.status !== "active") return null;

    try {
      const move = this.chess.move({ from, to, promotion });
      if (move) {
        const currentTime = Date.now();
        // Update time for the player who just moved
        // const elapsedTime = currentTime - this.lastMoveTime;
        // this.players[this.currentTurn].timeRemaining -= elapsedTime;

        // Update game state
        this.currentTurn = this.chess.turn() === "w" ? "white" : "black";
        // this.lastMoveTime = currentTime;
        this.moveHistory.push({
          ...move,
          // timeRemaining: this.players[move.color].timeRemaining,
        });

        // Check game ending conditions
        this.checkGameEnd();

        return {
          move,
          gameState: this.getGameState(),
        };
      }
    } catch (error) {
      console.error("Invalid move:", error);
    }
    return null;
  }

  // Timer management
  startTimers() {
    if (this.timerInterval) clearInterval(this.timerInterval);

    this.timerInterval = setInterval(() => {
      if (this.status === "active") {
        const currentTime = Date.now();
        const elapsedTime = currentTime - this.lastMoveTime;
        this.players[this.currentTurn].timeRemaining -= 100; // Update every 100ms

        if (this.players[this.currentTurn].timeRemaining <= 0) {
          this.endGame(
            this.currentTurn === "white" ? "black" : "white",
            "timeout"
          );
        }
      }
    }, 100);
  }

  stopTimers() {
    if (this.timerInterval) {
      clearInterval(this.timerInterval);
      this.timerInterval = null;
    }
  }

  // Helper methods
  getPlayerColor(socketId) {
    if (this.players.white.socketId === socketId) return "white";
    if (this.players.black.socketId === socketId) return "black";
    return null;
  }

  areAllPlayersConnected() {
    return this.players.white.connected && this.players.black.connected;
  }

  checkGameEnd() {
    if (this.chess.isCheckmate()) {
      this.endGame(
        this.currentTurn === "white" ? "black" : "white",
        "checkmate"
      );
    } else if (this.chess.isDraw()) {
      this.endGame(null, "draw");
    }
  }

  endGame(winner, reason) {
    this.status = "completed";
    this.winner = winner;
    this.gameOverReason = reason;
    this.stopTimers();
  }

  getGameState() {
    return {
      id: this.id,
      status: this.status,
      currentTurn: this.currentTurn,
      fen: this.chess.fen(),
      players: {
        white: {
          ...this.players.white,
          inCheck: this.chess.isCheck() && this.currentTurn === "white",
        },
        black: {
          ...this.players.black,
          inCheck: this.chess.isCheck() && this.currentTurn === "black",
        },
      },
      moveHistory: this.moveHistory,
      winner: this.winner,
      gameOverReason: this.gameOverReason,
    };
  }
}
