import { Chess } from "chess.js";

//! Some code is generated by claude
export class ChessGame {
  constructor(player1, player2, timeSeconds) {
    this.id = `${Date.now()}${Math.random()
      .toString(36)
      .substring(2, 10)
      .toUpperCase()}`;

    // Randomly assign colors
    const isPlayer1White = Math.random() < 0.5;

    // Player information
    this.players = {
      white: {
        ...(isPlayer1White ? player1 : player2),
        timeRemaining: timeSeconds * 1000, // Convert to milliseconds
        connected: false,
        socketId: isPlayer1White ? player1.socketId : player2.socketId,
      },
      black: {
        ...(isPlayer1White ? player2 : player1),
        timeRemaining: timeSeconds * 1000,
        connected: false,
        socketId: isPlayer1White ? player2.socketId : player1.socketId,
      },
    };

    // Game state
    this.status = "pending"; // pending, active, paused, completed, abandoned
    this.startTime = null;
    this.currentTurn = "white";
    this.winner = null;
    this.gameOverReason = null;

    // Chess logic
    this.chess = new Chess();
    this.moveHistory = [];

    //* Timer Setup
    this.timerInterval = null;
  }

  // Player connection management
  handlePlayerConnect(socketId) {
    const color = this.getPlayerColor(socketId);
    if (color) {
      this.players[color].connected = true;
      if (this.areAllPlayersConnected() && this.status === "pending") {
        this.startGame();
      }
      return true;
    }
    return false;
  }

  handlePlayerDisconnect(playerId) {
    const color = this.getPlayerColor(playerId);
    if (color) {
      this.players[color].connected = false;

      this.winner = color === "white" ? "black" : "white";

      //* For now lets do gameover if the user leaves
      this.gameOverReason = "player_disconnected";
      this.endGame(this.winner, this.gameOverReason);
    }
  }

  // Game state management
  startGame() {
    this.status = "active";
    this.startTime = Date.now();
  }

  // Move handling
  makeMove(from, to, promotion) {
    if (this.status !== "active") return null;

    try {
      const move = this.chess.move({ from, to, promotion });
      if (move) {
        this.currentTurn = this.chess.turn() === "w" ? "white" : "black";
        this.moveHistory.push({
          ...move,
        });

        this.checkGameEnd();

        return {
          move,
          gameState: this.getGameState(),
        };
      }
    } catch (error) {
      console.error("Invalid move:", error);
    }
    return null;
  }

  // Helper methods
  getPlayerColor(playerId) {
    if (this.players.white.playerId === playerId) return "white";
    if (this.players.black.playerId === playerId) return "black";
    return null;
  }

  areAllPlayersConnected() {
    return this.players.white.connected && this.players.black.connected;
  }

  checkGameEnd() {
    if (this.chess.isCheckmate()) {
      this.endGame(
        this.currentTurn === "white" ? "black" : "white",
        "checkmate"
      );
    } else if (this.chess.isDraw()) {
      this.endGame(null, "draw");
    }
  }

  endGame(winner, reason) {
    this.status = "completed";
    this.winner = winner;
    this.gameOverReason = reason;
  }

  getGameState() {
    return {
      id: this.id,
      status: this.status,
      currentTurn: this.currentTurn,
      fen: this.chess.fen(),
      players: this.players,
      moveHistory: this.moveHistory,
      winner: this.winner,
      gameOverReason: this.gameOverReason,
    };
  }
}
